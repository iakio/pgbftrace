<!DOCTYPE html>
<html>
<head>
    <title>PostgreSQL Buffer Tracer</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; margin: 20px; background-color: #f0f0f0; }
        h1 { color: #333; }
        #messages { margin-top: 20px; padding: 10px; border: 1px solid #ccc; background-color: #fff; width: 80%; max-height: 150px; overflow-y: scroll; box-sizing: border-box; }
        canvas { border: 1px solid #aaa; background-color: #f8f8f8; margin-top: 20px; }
        #legend { margin-top: 20px; width: 80%; display: flex; flex-wrap: wrap; justify-content: center; }
        .legend-item { display: flex; align-items: center; margin: 5px 10px; }
        .legend-color { width: 15px; height: 15px; border: 1px solid #ccc; margin-right: 5px; }
        .table-canvas-wrapper {
            margin: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <h1>PostgreSQL Buffer Trace Visualizer</h1>
    <div id="legend"></div>
    <div id="canvas-container" style="display: flex; flex-wrap: wrap; gap: 20px; justify-content: center;">
        <!-- Dynamically generated canvases will go here -->
    </div>
    <div id="messages"></div>

    <script>
        const messages = document.getElementById("messages");
        const canvasContainer = document.getElementById("canvas-container"); // 新しいコンテナ

        const BLOCK_SIZE = 5; // 各ブロックを描画する際のピクセルサイズ
        const BLOCK_MARGIN = 1; // ブロック間のマージン
        const HEADER_HEIGHT = 20; // テーブル名表示領域の高さ
        const TABLE_PADDING = 10; // テーブル領域の外側パディング
        const CANVAS_WIDTH_PER_TABLE = 400; // 各テーブルのCanvasの幅（固定）

        let relations = []; // 全リレーション情報
        const ctxs = {}; // relfilenodeごとに描画コンテキストを保存

        // Canvasの初期描画（各テーブルのCanvasを生成）
        function createAndDrawTableCanvas(rel) {
            const tableDiv = document.createElement("div");
            tableDiv.className = "table-canvas-wrapper";
            tableDiv.style.border = "1px solid #ddd";
            tableDiv.style.padding = "10px";
            tableDiv.style.backgroundColor = "#fff";
            tableDiv.style.borderRadius = "5px";

            const headerDiv = document.createElement("div");
            headerDiv.className = "table-header";
            headerDiv.style.fontWeight = "bold";
            headerDiv.style.marginBottom = "5px";
            headerDiv.textContent = `${rel.relname} (OID: ${rel.oid}, Blocks: ${rel.total_blocks})`;
            tableDiv.appendChild(headerDiv);

            const canvas = document.createElement("canvas");
            canvas.id = `canvas-${rel.relfilenode}`; // Canvas IDはrelfilenode
            canvas.width = CANVAS_WIDTH_PER_TABLE; // 各テーブルのCanvasは固定幅
            tableDiv.appendChild(canvas);
            canvasContainer.appendChild(tableDiv);

            const ctx = canvas.getContext("2d");
            ctxs[rel.relfilenode] = ctx; // コンテキストをrelfilenodeで管理

            // Canvasの高さ計算
            const blocksPerRow = Math.floor(
                (canvas.width - 2 * TABLE_PADDING) / (BLOCK_SIZE + BLOCK_MARGIN)
            );
            const numRows = Math.ceil(rel.total_blocks / blocksPerRow);
            canvas.height = numRows * (BLOCK_SIZE + BLOCK_MARGIN) + TABLE_PADDING;

            // 各テーブルの描画情報を更新 (描画開始Y座標はCanvas内での相対座標になる)
            rel.drawInfo = {
                blocksStartY: TABLE_PADDING, // 各Canvas内でのブロック開始Y座標
                blocksPerRow: blocksPerRow,
            };

            // 初期グリッド描画
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#f8f8f8";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            let blockX = TABLE_PADDING;
            let blockY = TABLE_PADDING; // 各Canvas内でのブロック開始Y座標

            for (let i = 0; i < rel.total_blocks; i++) {
                ctx.fillStyle = "#eee"; // デフォルトのブロック色
                ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
                blockX += BLOCK_SIZE + BLOCK_MARGIN;
                if ((i + 1) % blocksPerRow === 0) {
                    blockX = TABLE_PADDING;
                    blockY += BLOCK_SIZE + BLOCK_MARGIN;
                }
            }
        }

        function createLegend(relationsData) {
            const legendDiv = document.getElementById("legend");
            legendDiv.innerHTML = ""; // クリア
            relationsData.forEach((rel) => {
                const legendItem = document.createElement("div");
                legendItem.className = "legend-item";
                const colorBox = document.createElement("div");
                colorBox.className = "legend-color";
                colorBox.style.backgroundColor = "#eee"; // デフォルト色に設定
                const text = document.createTextNode(`${rel.relname}`);
                legendItem.appendChild(colorBox);
                legendItem.appendChild(text);
                legendDiv.appendChild(legendItem);
            });
        }

        // 1. Fetch relation info first
        fetch("/api/relations")
            .then((response) => response.json())
            .then((relationsData) => {
                relations = relationsData; // グローバル変数に保存
                console.log("Initialized relations:", relations);
                messages.innerHTML += `<p>Initialized with ${relations.length} relations.</p>`;

                // 各テーブルごとにCanvasを作成し描画
                relations.forEach(createAndDrawTableCanvas);

                // 凡例作成
                createLegend(relations);

                // 2. After fetching info, connect to WebSocket
                setupWebSocket();
            })
            .catch((error) => {
                console.error("Error fetching relations:", error);
                messages.innerHTML += `<p>Error fetching relations: ${error.message}</p>`;
            });

        function setupWebSocket() {
            const ws = new WebSocket(`ws://${window.location.host}/ws`);
            ws.binaryType = "arraybuffer"; // Important: receive data as binary

            ws.onopen = function (event) {
                messages.innerHTML += "<p>Connected to WebSocket.</p>";
            };

            ws.onmessage = function (event) {
                const dataView = new DataView(event.data);
                const relfilenode = dataView.getUint32(0, false); // 最初の4バイトはrelfilenode
                const block = dataView.getUint32(4, false); // 次の4バイトはblock

                const messageText = `Received Trace: RelFilenode=${relfilenode}, Block=${block}`;
                // console.log(messageText); // ログが多すぎるときはコメントアウト

                const messageElement = document.createElement("p");
                messageElement.textContent = messageText;
                // メッセージ領域が溢れないように調整
                if (messages.children.length > 100) {
                    messages.removeChild(messages.firstChild);
                }
                messages.appendChild(messageElement);
                messages.scrollTop = messages.scrollHeight;

                highlightBlock(relfilenode, block);
            };

            ws.onclose = function (event) {
                messages.innerHTML += "<p>Disconnected from WebSocket.</p>";
            };

            ws.onerror = function (error) {
                messages.innerHTML += `<p>WebSocket Error: ${
                    error.message || "Unknown error"
                }</p>`;
            };
        }

        // ブロックをハイライトする関数
        function highlightBlock(relfilenode, blockNumber) {
            const relInfo = relations.find((r) => r.relfilenode === relfilenode);
            if (!relInfo || !relInfo.drawInfo) {
                console.warn(
                    `Relation with relfilenode ${relfilenode} not found or drawInfo missing.`
                );
                return;
            }

            const ctx = ctxs[relfilenode]; // 対象Canvasのコンテキストを取得
            if (!ctx) {
                console.warn(`Canvas context for relfilenode ${relfilenode} not found.`);
                return;
            }

            const blocksPerRow = relInfo.drawInfo.blocksPerRow; // 各CanvasのblocksPerRowを使用
            const row = Math.floor(blockNumber / blocksPerRow);
            const col = blockNumber % blocksPerRow;

            const x = TABLE_PADDING + col * (BLOCK_SIZE + BLOCK_MARGIN);
            const y =
                relInfo.drawInfo.blocksStartY + row * (BLOCK_SIZE + BLOCK_MARGIN); // Canvas内でのY座標

            // ハイライト (一時的に色を変える)
            ctx.fillStyle = "#87CEEB"; // アクセス時の色（目に優しいソフトブルー）
            ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);

            // タイムアウトで元の色に戻す (デフラグ風)
            setTimeout(() => {
                ctx.fillStyle = "#eee"; // デフォルトのブロック色に戻す (意図的な残影)
                ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
            }, 500); // 0.5秒後に戻る
        }
    </script>
</body>
</html>